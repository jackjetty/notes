#1. 简述
* **内存**是一种临时存储器，也被称为随机存取存储器（RAM），所有的计算机、智能手机及其他**可编程设备**都包含微处理器和一定数量的内存，用地址来定位不同的存储区域，像编号一样。
* **硬盘**可以永久的存储数据。
* **微处理器**负责执行程序，它会**从RAM中获取要执行的应用程序二进制码及相关联的数据**，这包括显示到屏幕上的数据以及用户输入的数据。
* **变量**让程序员能够将数据**临时**存储一段时间，其实就是内存中存储单元地址的别名，便于使用，不易出错，也避免不小心覆盖原有数据。
* **常量**让程序员能够定义**不允许修改**的东西。

#2. 变量
* 变量类型
    * 向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。
    * 无符号变量不能用于存储负值
    * bool适用于表示ON或OFF、有或没有、可用或不可用等设置和标记
    * char用于存储单个字符，长度为一个字节，正好适合在内存中用数字表示，因此基于ASCII码作为数字值存在了内存中，包含大小写字母、0-9以及一些特殊字符和特殊键击值（如DEL）
    * 取值范围
        * 不同数据类型、有无符号（一般符号位是最高有效位MSB）的变量取值范围不同，使用变量时要先选择合适取值范围的变量类型
        * 取值范围最大值加1或最小值减1，会导致回绕或溢出（如最大值加1是否变成最小的复数，取决于编译器行为），会导致应用程序行为不可测
    * POD（Plain Old Data），除了基本数据类型，还包括聚合数据类型（结构、枚举、共用体和类）
* 变量名
    * 要友好，替代了数据在内存中的存储地址。
    * 描述性要好，比变量名过长要优先
    * 可以有数字、字母、_，但不可以数字开头，不能包含空格、保留字和算术运算符。
    * 变量用驼峰命名、函数和类等用Pascal命名，匈牙利命名已不太流行（以类型缩写开头）
* 作用域
    * 在作用域外，变量时未定义的实体，编译器对其一无所知
    * 超出作用域或程序终止后，内存中的数据将丢失，除非程序显示地将其存储到硬盘等永久性存储介质中
    * 不同作用域的变量即使变量名相同，也被编译器视为不同的独立的实体
    * 全局变量不要轻易使用，因为别人可能会不小心修改到，更好的方式是通过返回值进行数据传递
* 声明
    * 最好在声明后赋初始值，避免其初始值不可知。
    * 虽然可以同时声明和初始化多个变量，但最好需要时再声明，让代码易于理解。
* **组块分隔符**（chunking separator）
    * C++14引入，用单引号表示
    * 提高数字字面量的可读性
    * C#中有类似的，用逗号表示
* 使用**siezeof**确定变量的长度
    * 变量长度指的是程序员声明变量时，编译器将预留多少内存，用于存储赋给该变量的数据，长度因类型而异。
    * sizeof的单位是字节
    * sizeof(int)
    * 即使同一数据类型，不同平台得到的长度也不同
    * 有无符号数取值范围不同，但长度相同
    * C++11引入了固定宽度的整型，让您能够以位为单位指定整数的宽度，需要包含头文件<cstdint>，都有int16_t等。
* **缩窄转换错误**
    * 使用取值范围较大的变量来初始化取值范围较小的变量时，将面临出现缩窄转换错误的风险。
    * 不会导致编译不通过，也不是必现的，但导致行为不可测
    * 可通过列表初始化禁止和避免：short anotherNum {largeNum}会提示报错
* 使用**auto**自动推断类型
    * C#中有类似的var
    * C++11以上支持
    * 这将指定变量类型的任务留给了编译器，编译器检查赋给变量的初值的性质，再确定将变量声明为什么类型最合适
    * 必须对变量进行初始化，不然编译器无法进行判断，会有编译错误
    * 好处是让编程更加容易，也少写和避免人为判断类型
* 使用**typedef**替换变量类型
    * typedef unsigned int STRICTLY_POSITIVE_INTEGER;
    * 将变量类型名替换为您认为方便的名字，即自己起了一个别名
    * C#中的using也可以做到
    * 编译器会去进行替换

#3. 常量
* 和变量类似，只是不能修改，同样占用内存空间，使用
* 名称标识为其预留的空间的地址
* 用于你不希望这个值被覆盖、修改时，这是一个好习惯，避免其他程序员或自己不小心的修改
* 一定要初始化，避免不确定性，不要随机。。
* 对变量操作时，一定要判断取值范围，避免溢出，可能会导致应用程序崩溃
* **字面常量**
    * 可以是任意类型，从C++14起，还可以使用二进制字面量：int i = 0b1010;
    * C++中还可以定义自己的字面量，如10_km
* 使用**const**将变量声明为常量
    * 声明在编译期间长度固定的静态数组时，常量很有用
* 使用**constexpr**定义常量表达式
    * 可以让常量声明像函数：constexpr double GetPi() {return 22.0 / 7;}
    * 在一个常量表达式中，可使用另一个常量表达式：constexpr double TwicePi() {return 2 * GetPi();}
    * 提供了优化可能性，可能在编译阶段引发优化，即编译器直接去进行替换，把表达式替换成值，比如第二个会把TwicePi()都替换为6.28571，从而避免计算。但不能保证一定有编译阶段优化，这时编译器会忽略constexpr，视为常规函数进行编译。
    * 包含<cmatch>头文件后，大多数编译器通过M_PI提供高精度的pi值
    * 常量表达式必须包含简单的实现，并返回简单类型
    * C++14中，常量表达式可包含决策结构，如if、switch
* 使用**#define**定义常量
    * 不推荐，原始
    * 这个是一个预处理器宏，是简单的文本替换，不智能，编译器不知道也不关心常量的类型
    * 不是类型安全的
* 枚举
    * 在有些情况下，变量/常量不是有一个特定的值，而且有一组特定的取值
    * 使用**enum**定义枚举，由一组称为枚举量（emumerator，Voilet）的常量组成
    * 每个枚举量被转换为整数
        * 第一个默认为0
        * 没有特别指定整数值时，每个都比前一个大1
        * 如果给某个枚举量指定了特定整数，那么下一个枚举量以此为基础加1，当然也可以连续两个枚举量设置不同的整数值