* 概念
    * 设计模式是对被用来在特定的场景下解决一般设计问题的类和相互通信的对象的描述。
    * 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动
* 在一定环境中解决某一问题的方案的四个基本要素
    * 环境
    * 问题
    * 解决方案 - 设计模式
    * 效果
* 如何选择设计模式
    * **理解各个模式的意图、适用场景**。通读每个模式的意图，找到和问题相关的一个或多个模式。
    * **考虑哪些设计是可以改变的，即实际业务场景中哪些部分是可能发生变化的，那么这部分就要选择适当的设计模式使其变得抽象灵活**。主要是考虑那些是可以变化却不会引起重新设计。
    * 考虑设计模式是怎么样解决设计问题的。注意各个模式对于找到合适的对象、决定对象的粒度、指定对象的接口的影响。
    * 研究模式怎么样相互关联。
* 六大设计原则
    * **开闭原则（Open Close Principle）**
        * 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个**热插拔的效果**。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要**使用接口和抽象类**，后面的具体设计中我们会提到这点。
    * **里氏代换原则（Liskov Substitution Principle）**
        * 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP** 是继承复用的基石**，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是**对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。**
        * **即要保证子类始终可以替换父类，不会报错或者有逻辑问题。**
    * **依赖倒转原则（Dependence Inversion Principle）**
        * 这个原则**是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。**
        * **所谓倒转，就是说不像传统思维那样直接依赖于具体类，而是依赖于其高层抽象类或接口。**
    * **接口隔离原则（Interface Segregation Principle）**
        * 这个原则的意思是：**使用多个隔离的接口，比使用单个接口要好。**它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
        * **因此接口中定义的方法都比较少，通常接口用于定义用于继承实现的小功能集，而父类/抽象类用于定义用于继承实现的大功能集。**
    * **迪米特法则，又称最少知道原则（Demeter Principle）**
        * 最少知道原则是指：**一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。**
    * **合成复用原则（Composite Reuse Principle）**
        * 合成复用原则是指：**尽量使用合成/聚合的方式，而不是使用继承。**
        * **也就是说继承要慎用，会使子类强依赖/相关于父类。**
* ![设计模式关系](https://img2018.cnblogs.com/blog/106125/201905/106125-20190516134036238-117379733.png)
* 总结
    * **多使用继承、组合来实现设计模式，达到解耦的目的**
    * 接口多用于小功能的继承，抽象类多用于大功能或者一组功能的继承。
    * **组合/聚合关系的建立**
        * 使用者中有一个被依赖方或其列表/数组
        * 两种方式
            * 如果被依赖方比较固定，那么使可以**直接在构造函数中初始化**；
            * 如果被依赖方也抽象化了，那么通常**通过构造函数的参数形式将其传给使用者，而不是直接实例化。**
        * 很多设计模式中都使用了聚合或者组合，那么就要从这两种方式中选一个来为这两个对象建立聚合或者组合关系。
    * **如何确定使用哪个子类**
        * 有时调用者中直接使用具体类也无所谓？至少被调用者的现有代码不需要修改，只需要增加
        * 也可以通过配置文件、环境变量等方式来指定特定字符串，用来判断使用哪个具体子类
    * **多个设计模式可以结合起来用**
        * 一定要因地制宜。
        * 比如Decorator模式中，被装饰者可以多一层继承关系如一个抽象类，实现了部分方法，这其实相当于又是一个模板方法模式。
        * 比如Decorator模式中，除了普通装饰者还可以多一个组合类，批量操作其中组合的被装饰者List/Array，这其实相当于又是一个组合模式。