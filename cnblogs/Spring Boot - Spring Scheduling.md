* 有时应用需要定时（如凌晨）执行一些任务（比如计算一些数据并存下来留给后续使用）
* 使用
    * 使用@EnableScheduling注解启用Scheduling功能：**不一定要标注在启动类上，也可以标注在@Configuration配置类上**
    * 方法上加@Scheduled注解，方法会按照参数定期执行
* @Scheduled参数
    * zone：设置时区，按照时区定时运行
    * cron：值为字符串，按照时钟定时运行
        * 字符串至少包含六部分（在字符串中用空格间隔开）
            * 秒（0~59），支持, - \* /
            * 分（0~59），支持, - \* /
            * 小时（0~23），支持, - \* /
            * 日（1~31），支持, - \* ? / L W
            * 月（1~12或JAN~DEC），支持, - \* /
            * 星期几（1~7或SUN~SAT)，支持, - \* ? / L \#
            * 年（可为空，空表示任意年），支持, - \* /
        * 例如cron-"0 0 0 * * ?"
    * fixedDelay：以固定的频率执行，单位为毫秒，方法**休息的间隔时间**是相同的
    * fixedRate：以固定的频率执行，单位为毫秒，方法**启动的间隔时间**是相同的
        * 方法的注解参数可以使用配置文件变量和默认值，如：@Scheduled(fixedRateString = "${assets.cache.refresh.rate:900000}")
    * initialDelay：和上面的三个参数搭配使用，不能单独使用，单位为毫秒，首次执行延时
* 默认只有一个线程在执行scheduled任务
    * 如果有两个方法在同一时刻执行，那么第二个其实是执行不了的，但是这个配置是可以改的，新建一个@Configuration的类继承自SchedulingConfigurer接口，重写configureTasks类，可以新建和设置一个ThreadPoolTaskScheduler。
* 注意在集群/负载均衡环境下，要想办法避免多个实例都执行了定时任务，会混乱
    * 可以单独出来只有一个服务器执行定时任务，但缺点是它挂了以后，就没有了，也就是没有使用集群/负载均衡的高可用功能了
    * **使用Quartz Scheduler**